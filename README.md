## Что-то типа документации. Этап 4

### Содержание
1. [Основная структура классов](#Основная-структура-классов)
2. [Компоненты](#Компоненты)
   1. [Общие поля и методы](#Общие-поля-и-методы)
   2. [Жизненный цикл и события компонента](#Жизненный-цикл-и-события-компонента)
   3. [Обобщения](#Обобщения)
   4. [Список существующих компонентов и их назначения](#Список-существующих-компонентов-и-их-назначения)
3. [Мировые объекты](#Мировые-объекты)
    1. [Конструктор и фабричные методы](#Конструктор-и-фабричные-методы)
    2. [Список существующих объектов](#Список-существующих-объектов)
___
### Основная структура классов
___
### Компоненты
Компонентами в данном проекте называются наследники
класса _WorldObjectComponent_. Компоненты содержат основную логику 
объектов мира, их различные комбинации позволяют сконструировать
объекты с совершенно разными свойствами.  

Для удобства, в названиях классов-компонентов 
пишется суффикс _Component_.  

Компоненты можно добавлять не только в момент создания объекта,
но и после этого. Это даёт возможности для дополнительной динамики.
Утрируя: мы можем создать компонент, который манипулирует другими
компонентами животного таким образом, что в итоге оно становится
зданием.  

Однако нельзя забывать, что одни компоненты могут зависеть от других,
и удаление первых приведёт к ошибкам в работе вторых.

Другое важное замечание: при использовании компонент очень важно 
проверять, не уничтожены ли они, и своевременно удалять ссылки на
них. Иначе вы не только будете использовать несуществующий компонент,
но и не дадите сборщику мусора в действительности удалить объект. 
Это может привести к многочисленным ошибкам типа 
_NullReferenceException_, причину которых сложно обнаружить через
Debug, так как вызываются они из других классов.

Для проверки следует использовать функцию

```C#
WorldObjectComponent.CheckWereDestroyed(component)
```

Она возвращает _true_, когда либо component,
либо component.WorldObject, либо component.WorldObject.Cell имеют
значение _null_.
<br/>
<br/>

#### Общие поля и методы
Все наследники _WorldObjectComponent_ имеют ссылку на экзмепляр 
_WorldObject_, содержащего их, и на _World_. Они также могут 
переопределять методы _Start()_, _Update()_, _OnDestroy()_, 
о которых будет сказано далее, использовать методы:
```c#
protected T GetComponent<T>() where T : WorldObjectComponent 
               //возвращает первый компонент типа T, содержащийся 
               //в WorldObject текущего компонента, или null
protected List<T> GetComponents<T>()
               //возвращает список всех компонентов данного типа.
               //например, реализующих некоторый интерфейс
public void CheckWereDestroyed(WorldObject worldObject) //проверяет, уничтожен ли этот объект
public void CheckWereDestroyed(WorldObjectComponent component) //проверяет, уничтожен ли этот компонент
protected void Destroy() //уничтожает текущий компонент с вызовом OnDestroy()
```
В некоторых случаях необходимо удалить компонент не вызывая 
_OnDestroy()_. Это можно сделать следующей строкой кода:
```c#
WorldObject.RemoveComponent(this)
```
Тем же методом можно удалить и любой другой компонент этого объекта
извне.
Чтобы удалить другой компонент, вызвав OnDestroy(), используйте
```c#
WorldObject.DestroyComponent<T>() //где T - соответствующий тип
```
Для добавления нового компонента используйте:
```c#
WorldObject.AddComponent(component)
```
При этом не следует использовать этот метод в конструкторе 
класса-наследника _WorldObject_, так как он вызывает _Start()_ компонента.
О том, чем это опасно - в следующем разделе.

####Жизненный цикл и события компонента
Инициализация компонента начинается с конструктора. Здесь следует
задавать все параметры, которые не могут быть получены из других
компонентов. В конструктор также передаётся тот объект, которому будет
принадлежать данный компонент.

Далее вызывается метод _Start()_. Здесь следует через _GetComponent_
и _GetComponents_ получить все компоненты, которые определены для объекта
изначально и будут использованы в будущем. Вызов указанных методов
довольно трудоёмок, поэтому следует минимизировать количество их вызовов. 
Для этого, как правило, и используется _Start_.

По этой причине _Start_ должен вызываться уже после того, как в объект
добавлены все основные компоненты. Поэтому в конструкторе объекта
компоненты добавляются через
```c#
components.Add(component)
```
А в дальнейшем через
```c#
AddComponent(component)
```

Далее, пока компонент или объект не будет уничтожен, вызывается метод
_Update()_. Этот метод вызывается каждый тик мирового таймера и здесь,
соответственно, прописывается всё то, что должно происходить какждый
тик. Если какой-то компонент в своём _Update-методе_ уничтожил объект, 
то для следующих компонент в списке _Update()_ вызван не будет.

Перед уничтожением компонента вызывается метод _OnDestroy()_. При 
уничтожении объекта сначала вызывается метод _OnDestroy()_, а потом уже
выполняется отвязка компонентов от него, поэтому в методе _OnDestroy()_
можно обращаться к любым компонентам объекта.

Чаще всего _OnDestroy()_ используется для создания на месте старого
объекта нового. Например, при уничтожении _EggComponent_ создаётся
новый _Animal_.

#### Обобщения
#### Список существующих компонентов и их назначения
___
### Мировые объекты
#### Конструктор и фабричные методы
#### Список существующих объектов